<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Another Product Invented Mancala</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #fff;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1 {
      margin: 1rem 0 0.5rem;
      text-align: center;
      line-height: 1.2;
    }
    #gameContainer {
      position: relative;
      width: 720px; /* same as canvas internal width */
      max-width: 100%;
    }
    canvas {
      display: block;
      background: #f5deb3;
      width: 100%;
      height: auto;
    }
    .overlayScreen {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: none; /* shown/hidden dynamically */
      background: rgba(255,255,255,0.95);
      align-items: center;
      justify-content: center;
      flex-direction: column;
      text-align: center;
      z-index: 5;
      padding: 20px;
      box-sizing: border-box;
    }
    button {
      font-size: 18px;
      margin: 10px;
      padding: 10px 20px;
      cursor: pointer;
    }
    /* Logo placed in bottom-right corner */
    #logo {
      position: fixed;
      bottom: 10px;
      right: 10px;
      max-width: 100px;
      z-index: 2000;
    }
    /* Bottom bar */
    #bottomBar {
      width: 720px;
      max-width: 100%;
      background: #fff;
      border-top: 1px solid #ccc;
      display: flex;
      align-items: center;
      justify-content: flex-start;
      padding: 10px;
      box-sizing: border-box;
      margin-top: 5px;
    }
  </style>
</head>
<body>
  <!-- Header with two-line title -->
  <h1>Another Product Invented<br>Mancala</h1>

  <div id="gameContainer">
    <!-- MENU SCREEN -->
    <div id="menuScreen" class="overlayScreen" style="display: flex;">
      <button id="newGameBtn">New Game</button>
      <button id="instructionsBtn">Instructions</button>
    </div>

    <!-- INSTRUCTIONS SCREEN -->
    <div id="instructionsScreen" class="overlayScreen">
      <h2>How to Play Mancala</h2>
      <p>
        The objective is to collect more seeds than your opponent.<br>
        On your turn, click one of your pits (on your side) to pick up all its seeds and distribute them counterclockwise.<br>
        Seeds are dropped one by one in the following pits (skipping your opponent’s store).<br>
        If your last seed lands in your store, you get another turn.<br>
        If it lands in an empty pit on your side, you capture that seed along with any seeds in the opposite pit.<br>
        The game ends when one side’s pits are empty. The remaining seeds are collected, and the winner is the one with the most seeds.<br>
        Press [M] to return to the Main Menu.
      </p>
    </div>

    <!-- SIDE CHOICE SCREEN -->
    <div id="sideScreen" class="overlayScreen">
      <p>Choose Your Side:</p>
      <button id="southSideBtn">South [S]</button>
      <button id="northSideBtn">North [N]</button>
      <p>You can also press S or N on your keyboard.</p>
    </div>

    <!-- DIFFICULTY SCREEN -->
    <div id="difficultyScreen" class="overlayScreen">
      <p>Select Difficulty:</p>
      <button id="easyBtn">Easy [E]</button>
      <button id="mediumBtn">Medium [M]</button>
      <button id="hardBtn">Hard [H]</button>
      <p>You can also press E, M, or H on your keyboard.</p>
    </div>

    <!-- GAME OVER SCREEN -->
    <div id="gameOverScreen" class="overlayScreen">
      <h2 id="gameOverText"></h2>
      <button id="gameOverNewGameBtn">New Game</button>
      <p>Press [M] to return to the Main Menu.</p>
    </div>

    <!-- Mancala Game Canvas -->
    <canvas id="mancalaCanvas" width="720" height="500"></canvas>
    <!-- Bottom bar -->
    <div id="bottomBar">
      <span>Click a pit to move. Press [M] for menu.</span>
    </div>
  </div>

  <!-- Logo -->
  <img id="logo" src="logo.png" alt="Logo">

  <script>
    /************ Global Variables & State ************/
    const canvas = document.getElementById("mancalaCanvas");
    const ctx = canvas.getContext("2d");

    const menuScreen = document.getElementById("menuScreen");
    const instructionsScreen = document.getElementById("instructionsScreen");
    const sideScreen = document.getElementById("sideScreen");
    const difficultyScreen = document.getElementById("difficultyScreen");
    const gameOverScreen = document.getElementById("gameOverScreen");

    let gameState = "menu";  // states: menu, instructions, side_choice, difficulty_choice, playing, game_over
    let playerSide = null;   // "south" or "north" chosen by human
    let difficulty = null;   // "easy", "medium", "hard"
    let currentPlayer = null;  // "south" or "north" (whose turn it is)
    let board = [];  // 14-element array: indices 0-5: South pits, 6: South store, 7-12: North pits, 13: North store.
    let isAnimating = false;  // block input during animations
    let aiThinking = false;

    const WIDTH = 720, HEIGHT = 500;

    // Pit geometry definitions
    const pitPositions = {}; // Map pit index -> position and size info.
    const marginX = 120;
    const marginY = 50;
    const pitRadius = 40;
    const storeWidth = 80, storeHeight = 200;

    function computePitPositions() {
      let spacing = (WIDTH - 2 * marginX) / 6;
      // South pits (indices 0-5): left-to-right at bottom.
      for (let i = 0; i < 6; i++) {
        let cx = marginX + spacing/2 + i * spacing;
        let cy = HEIGHT - marginY;
        pitPositions[i] = { cx, cy, radius: pitRadius, type: "pit" };
      }
      // North pits (indices 7-12): arranged in reverse so pit 12 is leftmost.
      for (let i = 7; i < 13; i++) {
        let idx = i - 7;
        let cx = marginX + spacing/2 + (5 - idx) * spacing;
        let cy = marginY;
        pitPositions[i] = { cx, cy, radius: pitRadius, type: "pit" };
      }
      // South store (index 6) on the right.
      pitPositions[6] = { cx: WIDTH - marginX/2, cy: HEIGHT/2, width: storeWidth, height: storeHeight, type: "store" };
      // North store (index 13) on the left.
      pitPositions[13] = { cx: marginX/2, cy: HEIGHT/2, width: storeWidth, height: storeHeight, type: "store" };
    }

    // Initialize board: 4 seeds per pit; stores start at 0.
    function initBoard() {
      board = [];
      for (let i = 0; i < 14; i++) {
        board[i] = (i === 6 || i === 13) ? 0 : 4;
      }
    }

    // Returns true if pit index belongs to the given player.
    function isOwnPit(index, player) {
      if (player === "south") return index >= 0 && index <= 5;
      if (player === "north") return index >= 7 && index <= 12;
      return false;
    }

    // Get legal moves for current player (pits on their side with seeds).
    function getLegalMoves() {
      let moves = [];
      if (currentPlayer === "south") {
        for (let i = 0; i < 6; i++) { if (board[i] > 0) moves.push(i); }
      } else if (currentPlayer === "north") {
        for (let i = 7; i <= 12; i++) { if (board[i] > 0) moves.push(i); }
      }
      return moves;
    }

    /************ Image Loading ************/
    let pitImg = null, seedImg = null, handImg = null;
    function loadImages(callback) {
      let loaded = 0;
      const total = 3;
      function checkLoaded() { if (++loaded === total) callback(); }
      pitImg = new Image();
      pitImg.src = "images/pit.png";
      pitImg.onload = checkLoaded;
      seedImg = new Image();
      seedImg.src = "images/seed.png";
      seedImg.onload = checkLoaded;
      handImg = new Image();
      handImg.src = "images/hand.png";
      handImg.onload = checkLoaded;
    }

    /************ Animation Variables ************/
    let handPos = { x: 0, y: 0 };
    let handVisible = false;

    // Animate the hand moving from "from" to "to" over "duration" ms.
    function animateHand(from, to, duration, callback) {
      let startTime = performance.now();
      handVisible = true;
      function step(now) {
        let elapsed = now - startTime;
        let t = Math.min(elapsed / duration, 1);
        handPos.x = from.x + (to.x - from.x) * t;
        handPos.y = from.y + (to.y - from.y) * t;
        redraw();
        if (t < 1) {
          requestAnimationFrame(step);
        } else {
          callback();
        }
      }
      requestAnimationFrame(step);
    }

    // Animate the move from the chosen pit.
    // This function removes all seeds from pitIndex and then, one by one,
    // animates the hand moving to each destination pit and "dropping" a seed.
    function animateMove(pitIndex, finishCallback) {
      isAnimating = true;
      let stones = board[pitIndex];
      board[pitIndex] = 0; // remove seeds temporarily
      let destinations = [];
      let index = pitIndex;
      // Compute destination pits for each seed (skipping opponent’s store)
      for (let i = 0; i < stones; i++) {
        while (true) {
          index = (index + 1) % 14;
          if (currentPlayer === "south" && index === 13) continue;
          if (currentPlayer === "north" && index === 6) continue;
          break;
        }
        destinations.push(index);
      }
      let currentIndex = pitIndex;
      // Animate each seed drop sequentially.
      function animateNext(i) {
        if (i >= destinations.length) {
          // After all seeds are dropped, check capture.
          let lastIndex = destinations[destinations.length - 1];
          if (isOwnPit(lastIndex, currentPlayer) && board[lastIndex] === 1) {
            let opposite = 12 - lastIndex; // mapping for capture
            if (board[opposite] > 0) {
              let captured = board[opposite] + board[lastIndex];
              board[opposite] = 0;
              board[lastIndex] = 0;
              if (currentPlayer === "south") board[6] += captured;
              else board[13] += captured;
            }
          }
          handVisible = false;
          redraw();
          isAnimating = false;
          // Determine extra turn.
          let extra = (currentPlayer === "south" && lastIndex === 6) || (currentPlayer === "north" && lastIndex === 13);
          finishCallback(extra);
          return;
        }
        let dest = destinations[i];
        let fromPos = { x: pitPositions[currentIndex].cx, y: pitPositions[currentIndex].cy };
        let toPos = { x: pitPositions[dest].cx, y: pitPositions[dest].cy };
        animateHand(fromPos, toPos, 500, function(){
          // "Drop" the seed into destination pit.
          board[dest]++;
          currentIndex = dest;
          redraw();
          setTimeout(() => animateNext(i + 1), 200);
        });
      }
      animateNext(0);
    }

    /************ Drawing Functions ************/
    function drawBoard() {
      ctx.clearRect(0, 0, WIDTH, HEIGHT);
      // Draw board background.
      ctx.fillStyle = "#f5deb3";
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      // Draw each pit and store.
      for (let key in pitPositions) {
        let pos = pitPositions[key];
        // Draw pit/store using pitImg if loaded.
        if (pitImg) {
          if (pos.type === "pit") {
            let size = pos.radius * 2;
            ctx.drawImage(pitImg, pos.cx - pos.radius, pos.cy - pos.radius, size, size);
          } else {
            ctx.drawImage(pitImg, pos.cx - pos.width/2, pos.cy - pos.height/2, pos.width, pos.height);
          }
        } else {
          // Fallback drawing.
          if (pos.type === "pit") {
            ctx.beginPath();
            ctx.arc(pos.cx, pos.cy, pos.radius, 0, Math.PI * 2);
            ctx.fillStyle = "#deb887";
            ctx.fill();
            ctx.strokeStyle = "#8b4513";
            ctx.stroke();
          } else {
            ctx.beginPath();
            ctx.rect(pos.cx - pos.width/2, pos.cy - pos.height/2, pos.width, pos.height);
            ctx.fillStyle = "#d2b48c";
            ctx.fill();
            ctx.strokeStyle = "#8b4513";
            ctx.stroke();
          }
        }
        // Draw seeds inside pit.
        let count = board[key];
        if (seedImg && count > 0) {
          let num = count;
          // Arrange seeds in a circle.
          let angleStep = (2 * Math.PI) / num;
          let seedSize = 12; // size for the seed image
          for (let i = 0; i < num; i++) {
            let angle = i * angleStep;
            let offset = pos.radius * 0.6;
            let sx = pos.cx + offset * Math.cos(angle) - seedSize / 2;
            let sy = pos.cy + offset * Math.sin(angle) - seedSize / 2;
            ctx.drawImage(seedImg, sx, sy, seedSize, seedSize);
          }
        } else {
          // Fallback: show count as text.
          ctx.fillStyle = "#000";
          ctx.font = "20px sans-serif";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(board[key], pos.cx, pos.cy);
        }
      }
      // Draw bottom bar text.
      ctx.fillStyle = "#fff";
      ctx.fillRect(0, HEIGHT - 30, WIDTH, 30);
      ctx.fillStyle = "#000";
      ctx.font = "16px sans-serif";
      ctx.textAlign = "left";
      ctx.fillText("Click a pit to move. Press [M] for menu.", 10, HEIGHT - 10);
      // Draw the hand if visible.
      if (handVisible && handImg) {
        let handSize = 40;
        ctx.drawImage(handImg, handPos.x - handSize/2, handPos.y - handSize/2, handSize, handSize);
      }
    }

    function redraw() {
      drawBoard();
    }

    /************ Move Logic & Animation Integration ************/
    // Instead of instantly executing a move, animate it.
    function playerMakeMove(pitIndex) {
      if (isAnimating) return;
      // Only allow moves from the player's own pits.
      if (!isOwnPit(pitIndex, currentPlayer)) return;
      if (board[pitIndex] <= 0) return;
      animateMove(pitIndex, function(extraTurn) {
        if (checkGameOver()) {
          gameState = "game_over";
          let winner = getWinner();
          let resultText = (winner === "tie") ? "It's a tie!" : (winner === playerSide ? "You win!" : "You lose!");
          document.getElementById("gameOverText").innerHTML = "Game Over<br>" + resultText;
          showGameOver();
          return;
        }
        if (!extraTurn) currentPlayer = (currentPlayer === "south") ? "north" : "south";
        redraw();
      });
    }

    function aiMoveAction() {
      let legal = getLegalMoves();
      if (legal.length === 0) return;
      let chosen;
      if (difficulty === "easy") {
        chosen = legal[Math.floor(Math.random() * legal.length)];
      } else if (difficulty === "medium") {
        // Prefer moves that grant an extra turn.
        for (let move of legal) {
          let stones = board[move];
          let idx = move;
          for (let i = 0; i < stones; i++) {
            do {
              idx = (idx + 1) % 14;
              if (currentPlayer === "north" && idx === 6) continue;
              if (currentPlayer === "south" && idx === 13) continue;
              break;
            } while (true);
          }
          if ((currentPlayer === "south" && idx === 6) || (currentPlayer === "north" && idx === 13)) {
            chosen = move;
            break;
          }
        }
        if (chosen === undefined) chosen = legal[Math.floor(Math.random() * legal.length)];
      } else if (difficulty === "hard") {
        // A simple minimax decision (depth 4) based on store difference.
        chosen = minimaxDecision(board.slice(), currentPlayer, 4).move;
        if (chosen === null) chosen = legal[Math.floor(Math.random() * legal.length)];
      } else {
        chosen = legal[Math.floor(Math.random() * legal.length)];
      }
      animateMove(chosen, function(extraTurn) {
        if (checkGameOver()) {
          gameState = "game_over";
          let winner = getWinner();
          let resultText = (winner === "tie") ? "It's a tie!" : (winner === playerSide ? "You win!" : "You lose!");
          document.getElementById("gameOverText").innerHTML = "Game Over<br>" + resultText;
          showGameOver();
          return;
        }
        if (!extraTurn) currentPlayer = (currentPlayer === "south") ? "north" : "south";
        redraw();
      });
    }

    /************ Game-End Logic ************/
    function checkGameOver() {
      let southEmpty = true;
      for (let i = 0; i < 6; i++) { if (board[i] > 0) { southEmpty = false; break; } }
      let northEmpty = true;
      for (let i = 7; i <= 12; i++) { if (board[i] > 0) { northEmpty = false; break; } }
      if (southEmpty || northEmpty) {
        if (!southEmpty) {
          for (let i = 0; i < 6; i++) { board[6] += board[i]; board[i] = 0; }
        }
        if (!northEmpty) {
          for (let i = 7; i <= 12; i++) { board[13] += board[i]; board[i] = 0; }
        }
        return true;
      }
      return false;
    }

    function getWinner() {
      if (board[6] > board[13]) return "south";
      if (board[13] > board[6]) return "north";
      return "tie";
    }

    /************ Simple Minimax for AI (Depth 4) ************/
    function evaluateState(state, player) {
      return (player === "south") ? state[6] - state[13] : state[13] - state[6];
    }

    function getLegalMovesForState(state, player) {
      let moves = [];
      if (player === "south") {
        for (let i = 0; i < 6; i++) { if (state[i] > 0) moves.push(i); }
      } else {
        for (let i = 7; i <= 12; i++) { if (state[i] > 0) moves.push(i); }
      }
      return moves;
    }

    function simulateMove(state, move, player) {
      let newState = state.slice();
      let stones = newState[move];
      newState[move] = 0;
      let index = move;
      while (stones > 0) {
        index = (index + 1) % 14;
        if (player === "south" && index === 13) continue;
        if (player === "north" && index === 6) continue;
        newState[index]++;
        stones--;
      }
      function isOwn(idx, p) {
        return (p === "south" && idx >= 0 && idx <= 5) || (p === "north" && idx >= 7 && idx <= 12);
      }
      if (isOwn(index, player) && newState[index] === 1) {
        let opposite = 12 - index;
        if (newState[opposite] > 0) {
          let captured = newState[opposite] + newState[index];
          newState[opposite] = 0;
          newState[index] = 0;
          if (player === "south") newState[6] += captured;
          else newState[13] += captured;
        }
      }
      let extra = (player === "south" && index === 6) || (player === "north" && index === 13);
      return { state: newState, extra: extra };
    }

    function minimaxDecision(state, player, depth) {
      function maxValue(state, player, depth) {
        let legal = getLegalMovesForState(state, player);
        if (depth === 0 || legal.length === 0) return { value: evaluateState(state, player), move: null };
        let best = { value: -Infinity, move: legal[0] };
        for (let move of legal) {
          let sim = simulateMove(state, move, player);
          let nextPlayer = sim.extra ? player : (player === "south" ? "north" : "south");
          let result = (nextPlayer === player) ? maxValue(sim.state, player, depth - 1) : minValue(sim.state, player, depth - 1);
          if (result.value > best.value) best = { value: result.value, move: move };
        }
        return best;
      }
      function minValue(state, player, depth) {
        let opponent = (player === "south") ? "north" : "south";
        let legal = getLegalMovesForState(state, opponent);
        if (depth === 0 || legal.length === 0) return { value: evaluateState(state, player), move: null };
        let best = { value: Infinity, move: null };
        for (let move of legal) {
          let sim = simulateMove(state, move, opponent);
          let nextPlayer = sim.extra ? opponent : player;
          let result = (nextPlayer === opponent) ? minValue(sim.state, player, depth - 1) : maxValue(sim.state, player, depth - 1);
          if (result.value < best.value) best = { value: result.value, move: move };
        }
        return best;
      }
      return maxValue(state, player, depth);
    }

    /************ Input Handling ************/
    canvas.addEventListener("mousedown", function(e) {
      if (gameState !== "playing" || isAnimating) return;
      if (currentPlayer !== playerSide) return; // allow input only on player's turn
      let rect = canvas.getBoundingClientRect();
      let mx = e.clientX - rect.left;
      let my = e.clientY - rect.top;
      let legal = getLegalMoves();
      for (let move of legal) {
        let pos = pitPositions[move];
        let dx = mx - pos.cx, dy = my - pos.cy;
        if (Math.sqrt(dx * dx + dy * dy) < pos.radius) {
          playerMakeMove(move);
          return;
        }
      }
    });

    // Keyboard shortcuts.
    document.addEventListener("keydown", function(e) {
      let key = e.key.toLowerCase();
      if (gameState === "side_choice") {
        if (key === "s") document.getElementById("southSideBtn").click();
        if (key === "n") document.getElementById("northSideBtn").click();
      } else if (gameState === "difficulty_choice") {
        if (key === "e") document.getElementById("easyBtn").click();
        if (key === "m") document.getElementById("mediumBtn").click();
        if (key === "h") document.getElementById("hardBtn").click();
      } else if (["playing", "instructions", "game_over"].includes(gameState)) {
        if (key === "m") showMenu();
      }
    });

    /************ Screen Management ************/
    function hideAllScreens() {
      menuScreen.style.display = "none";
      instructionsScreen.style.display = "none";
      sideScreen.style.display = "none";
      difficultyScreen.style.display = "none";
      gameOverScreen.style.display = "none";
    }
    function showMenu() {
      hideAllScreens();
      gameState = "menu";
      menuScreen.style.display = "flex";
    }
    function showInstructions() {
      hideAllScreens();
      gameState = "instructions";
      instructionsScreen.style.display = "flex";
    }
    function showSideChoice() {
      hideAllScreens();
      gameState = "side_choice";
      sideScreen.style.display = "flex";
    }
    function showDifficultyChoice() {
      hideAllScreens();
      gameState = "difficulty_choice";
      difficultyScreen.style.display = "flex";
    }
    function showGameOver() {
      hideAllScreens();
      gameOverScreen.style.display = "flex";
    }

    /************ Main Loop ************/
    function mainLoop() {
      if (gameState === "playing") {
        if (currentPlayer !== playerSide && !isAnimating && !aiThinking) {
          aiThinking = true;
          setTimeout(() => {
            aiMoveAction();
            aiThinking = false;
          }, 1000);
        }
      }
      requestAnimationFrame(mainLoop);
    }

    /************ Button Handlers ************/
    document.getElementById("newGameBtn").onclick = function() { showSideChoice(); };
    document.getElementById("instructionsBtn").onclick = function() { showInstructions(); };
    document.getElementById("southSideBtn").onclick = function() {
      playerSide = "south";
      currentPlayer = "south";
      initBoard();
      redraw();
      showDifficultyChoice();
    };
    document.getElementById("northSideBtn").onclick = function() {
      playerSide = "north";
      currentPlayer = "north";
      initBoard();
      redraw();
      showDifficultyChoice();
    };
    document.getElementById("easyBtn").onclick = function() {
      difficulty = "easy";
      hideAllScreens();
      gameState = "playing";
    };
    document.getElementById("mediumBtn").onclick = function() {
      difficulty = "medium";
      hideAllScreens();
      gameState = "playing";
    };
    document.getElementById("hardBtn").onclick = function() {
      difficulty = "hard";
      hideAllScreens();
      gameState = "playing";
    };
    document.getElementById("gameOverNewGameBtn").onclick = function() { showSideChoice(); };

    /************ Start Everything ************/
    computePitPositions();
    initBoard();
    loadImages(function(){
      redraw();
      mainLoop();
    });
  </script>
</body>
</html>
