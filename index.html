<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Another Product Invented Mancala</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #fff;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1 {
      margin: 1rem 0 0.5rem;
      text-align: center;
      line-height: 1.2;
    }
    #gameContainer {
      position: relative;
      width: 720px;
      max-width: 100%;
    }
    canvas {
      display: block;
      background: #f5deb3;
      width: 100%;
      height: auto;
    }
    .overlayScreen {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: none;
      background: rgba(255,255,255,0.95);
      align-items: center;
      justify-content: center;
      flex-direction: column;
      text-align: center;
      z-index: 5;
      padding: 20px;
      box-sizing: border-box;
    }
    button {
      font-size: 18px;
      margin: 10px;
      padding: 10px 20px;
      cursor: pointer;
    }
    #logo {
      position: fixed;
      bottom: 10px;
      right: 10px;
      max-width: 100px;
      z-index: 2000;
    }
    #bottomBar {
      width: 720px;
      max-width: 100%;
      background: #fff;
      border-top: 1px solid #ccc;
      display: flex;
      align-items: center;
      justify-content: flex-start;
      padding: 10px;
      box-sizing: border-box;
      margin-top: 5px;
    }
  </style>
</head>
<body>
  <h1>Another Product Invented<br>Mancala</h1>
  <div id="gameContainer">
    <!-- MENU SCREEN -->
    <div id="menuScreen" class="overlayScreen" style="display: flex;">
      <button id="newGameBtn">New Game</button>
      <button id="instructionsBtn">Instructions</button>
    </div>
    <!-- INSTRUCTIONS SCREEN -->
    <div id="instructionsScreen" class="overlayScreen">
      <h2>How to Play Mancala</h2>
      <p>
        The objective is to collect more seeds than your opponent.<br>
        On your turn, click one of your pits (on your side) to pick up all its seeds and distribute them counterclockwise.<br>
        Seeds are dropped one by one (skipping your opponent’s store).<br>
        If your last seed lands in your store, you get another turn.<br>
        If it lands in an empty pit on your side, you capture that seed along with any seeds in the opposite pit.<br>
        The game ends when one side’s pits are empty. The remaining seeds are collected, and the winner is the one with the most seeds.<br>
        Press [M] to return to the Main Menu.
      </p>
    </div>
    <!-- SIDE CHOICE SCREEN -->
    <div id="sideScreen" class="overlayScreen">
      <p>Choose Your Side:</p>
      <button id="southSideBtn">South [S]</button>
      <button id="northSideBtn">North [N]</button>
      <p>You can also press S or N on your keyboard.</p>
    </div>
    <!-- DIFFICULTY SCREEN -->
    <div id="difficultyScreen" class="overlayScreen">
      <p>Select Difficulty:</p>
      <button id="easyBtn">Easy [E]</button>
      <button id="mediumBtn">Medium [M]</button>
      <button id="hardBtn">Hard [H]</button>
      <p>You can also press E, M, or H on your keyboard.</p>
    </div>
    <!-- GAME OVER SCREEN -->
    <div id="gameOverScreen" class="overlayScreen">
      <h2 id="gameOverText"></h2>
      <button id="gameOverNewGameBtn">New Game</button>
      <p>Press [M] to return to the Main Menu.</p>
    </div>
    <!-- Mancala Game Canvas -->
    <canvas id="mancalaCanvas" width="720" height="500"></canvas>
    <!-- Bottom bar -->
    <div id="bottomBar">
      <span>Click a pit to move. Press [M] for menu.</span>
    </div>
  </div>
  <!-- Logo -->
  <img id="logo" src="logo.png" alt="Logo">

  <script>
    /*--------------------------
      Helper: Remove White Background
      Pixels with R, G, B > 230 become transparent.
    ---------------------------*/
    function removeWhiteBackground(image, callback) {
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = image.width;
      tempCanvas.height = image.height;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.drawImage(image, 0, 0);
      const imgData = tempCtx.getImageData(0, 0, image.width, image.height);
      const data = imgData.data;
      for (let i = 0; i < data.length; i += 4) {
        if (data[i] > 230 && data[i+1] > 230 && data[i+2] > 230) {
          data[i+3] = 0;
        }
      }
      tempCtx.putImageData(imgData, 0, 0);
      const newImage = new Image();
      newImage.src = tempCanvas.toDataURL();
      newImage.onload = () => callback(newImage);
    }

    /*--------------------------
      Global Variables & State
    ---------------------------*/
    const canvas = document.getElementById("mancalaCanvas");
    const ctx = canvas.getContext("2d");

    const menuScreen = document.getElementById("menuScreen");
    const instructionsScreen = document.getElementById("instructionsScreen");
    const sideScreen = document.getElementById("sideScreen");
    const difficultyScreen = document.getElementById("difficultyScreen");
    const gameOverScreen = document.getElementById("gameOverScreen");

    let gameState = "menu";  // "menu", "instructions", "side_choice", "difficulty_choice", "playing", "game_over"
    let playerSide = null;   // "south" or "north"
    let difficulty = null;   // "easy", "medium", "hard"
    let currentPlayer = null;  // whose turn: "south" or "north"

    // The board: indices 0-5 (South pits), 6 (South store), 7-12 (North pits), 13 (North store).
    // Each pit is an array of seed objects; stores are arrays as well.
    let board = [];
    let isAnimating = false;
    let aiThinking = false;

    const WIDTH = 720, HEIGHT = 500;

    /*--------------------------
      Pit Geometry
    ---------------------------*/
    const pitPositions = {}; // Map pit index -> {cx, cy, ...}
    const marginX = 120;
    const marginY = 50;
    const pitRadius = 40;
    const storeWidth = 80, storeHeight = 200;

    function computePitPositions() {
      let spacing = (WIDTH - 2 * marginX) / 6;
      // South pits (indices 0–5)
      for (let i = 0; i < 6; i++) {
        let cx = marginX + spacing/2 + i * spacing;
        let cy = HEIGHT - marginY;
        pitPositions[i] = { cx, cy, radius: pitRadius, type: "pit" };
      }
      // North pits (indices 7–12) in reverse order (so pit 12 is leftmost)
      for (let i = 7; i < 13; i++) {
        let idx = i - 7;
        let cx = marginX + spacing/2 + (5 - idx) * spacing;
        let cy = marginY;
        pitPositions[i] = { cx, cy, radius: pitRadius, type: "pit" };
      }
      // South store (index 6) on right
      pitPositions[6] = { cx: WIDTH - marginX/2, cy: HEIGHT/2, width: storeWidth, height: storeHeight, type: "store" };
      // North store (index 13) on left
      pitPositions[13] = { cx: marginX/2, cy: HEIGHT/2, width: storeWidth, height: storeHeight, type: "store" };
    }

    /*--------------------------
      Image Loading
      Files: pit.png, hand.png, blueseed.png, redseed.png, greenseed.png, brownseed.png
    ---------------------------*/
    let pitImg = null, handImg = null;
    let seedImgs = []; // Array for seed images.
    function loadImages(callback) {
      let loaded = 0;
      const total = 2; // pit and hand images
      function checkLoaded() { if (++loaded === total) loadSeedImages(callback); }

      pitImg = new Image();
      pitImg.src = "images/pit.png";
      pitImg.onload = function() {
        removeWhiteBackground(pitImg, function(newImg) {
          pitImg = newImg;
          checkLoaded();
        });
      };

      handImg = new Image();
      handImg.src = "images/hand.png";
      handImg.onload = function() {
        removeWhiteBackground(handImg, function(newImg) {
          handImg = newImg;
          checkLoaded();
        });
      };
    }
    function loadSeedImages(callback) {
      // List your seed image files
      let seedFileNames = ["blueseed.png", "redseed.png", "greenseed.png", "brownseed.png"];
      let loadedSeeds = 0;
      for (let i = 0; i < seedFileNames.length; i++) {
        let img = new Image();
        img.src = "images/" + seedFileNames[i];
        img.onload = function() {
          removeWhiteBackground(img, function(newImg) {
            seedImgs.push(newImg);
            loadedSeeds++;
            if (loadedSeeds === seedFileNames.length) {
              callback();
            }
          });
        }
      }
    }

    /*--------------------------
      Board Initialization
      Each pit (indices except 6 and 13) gets 4 seeds fixed at game start.
    ---------------------------*/
    function initBoard() {
      board = [];
      for (let i = 0; i < 14; i++) {
        if (i === 6 || i === 13) {
          board[i] = []; // stores start empty
        } else {
          board[i] = [];
          for (let j = 0; j < 4; j++) {
            // Randomly select a seed image (fixed for the game)
            let seed = seedImgs[Math.floor(Math.random() * seedImgs.length)];
            board[i].push(seed);
          }
        }
      }
    }

    /*--------------------------
      Seed Drawing Helper
      For ≤6 seeds, return offsets on a small circle (radius 5) centered in the pit.
    ---------------------------*/
    function getSeedOffsets(count) {
      let offsets = [];
      if (count === 1) {
        offsets.push({ x: 0, y: 0 });
      } else {
        let r = 5;
        for (let i = 0; i < count; i++) {
          let angle = (2 * Math.PI * i) / count;
          offsets.push({ x: r * Math.cos(angle), y: r * Math.sin(angle) });
        }
      }
      return offsets;
    }

    /*--------------------------
      Animation Variables & Hand Animation
    ---------------------------*/
    let handPos = { x: 0, y: 0 };
    let handVisible = false;
    function animateHand(from, to, duration, callback) {
      let startTime = performance.now();
      handVisible = true;
      function step(now) {
        let elapsed = now - startTime;
        let t = Math.min(elapsed / duration, 1);
        handPos.x = from.x + (to.x - from.x) * t;
        handPos.y = from.y + (to.y - from.y) * t;
        redraw();
        if (t < 1) {
          requestAnimationFrame(step);
        } else {
          callback();
        }
      }
      requestAnimationFrame(step);
    }

    /*--------------------------
      Move Animation
      Moves seeds one-by-one from the selected pit.
      The moving seeds keep their fixed color.
    ---------------------------*/
    function animateMove(pitIndex, finishCallback) {
      isAnimating = true;
      let stones = board[pitIndex].length;
      let movingSeeds = board[pitIndex].slice();  // fixed seed objects
      board[pitIndex] = [];  // remove seeds from source pit
      let destinations = [];
      let index = pitIndex;
      for (let i = 0; i < stones; i++) {
        while (true) {
          index = (index + 1) % 14;
          if (currentPlayer === "south" && index === 13) continue;
          if (currentPlayer === "north" && index === 6) continue;
          break;
        }
        destinations.push(index);
      }
      let currentIndex = pitIndex;
      function animateNext(i) {
        if (i >= destinations.length) {
          let lastIndex = destinations[destinations.length - 1];
          // Capture rule: if last stone lands in empty pit on player's side and opposite has seeds
          if (isOwnPit(lastIndex, currentPlayer) && board[lastIndex].length === 0) {
            let opposite = 12 - lastIndex;
            if (board[opposite].length > 0) {
              let captured = board[opposite].concat(board[lastIndex]);
              board[opposite] = [];
              board[lastIndex] = [];
              if (currentPlayer === "south") {
                board[6] = board[6].concat(captured);
              } else {
                board[13] = board[13].concat(captured);
              }
            }
          }
          handVisible = false;
          redraw();
          isAnimating = false;
          let extra = (currentPlayer === "south" && lastIndex === 6) ||
                      (currentPlayer === "north" && lastIndex === 13);
          finishCallback(extra);
          return;
        }
        let dest = destinations[i];
        let fromPos = { x: pitPositions[currentIndex].cx, y: pitPositions[currentIndex].cy };
        let toPos = { x: pitPositions[dest].cx, y: pitPositions[dest].cy };
        animateHand(fromPos, toPos, 500, function(){
          board[dest].push(movingSeeds[i]);
          currentIndex = dest;
          redraw();
          setTimeout(() => animateNext(i + 1), 200);
        });
      }
      animateNext(0);
    }

    /*--------------------------
      Drawing the Board, Seeds, and Counters
      - For each pit and store, the counter is drawn above.
      - The seeds are drawn using their fixed color.
    ---------------------------*/
    function drawBoard() {
      ctx.clearRect(0, 0, WIDTH, HEIGHT);
      ctx.fillStyle = "#f5deb3";
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      for (let key in pitPositions) {
        let pos = pitPositions[key];
        // Draw pit/store background image
        if (pitImg) {
          if (pos.type === "pit") {
            let size = pos.radius * 2;
            ctx.drawImage(pitImg, pos.cx - pos.radius, pos.cy - pos.radius, size, size);
          } else {
            ctx.drawImage(pitImg, pos.cx - pos.width/2, pos.cy - pos.height/2, pos.width, pos.height);
          }
        } else {
          if (pos.type === "pit") {
            ctx.beginPath();
            ctx.arc(pos.cx, pos.cy, pos.radius, 0, Math.PI * 2);
            ctx.fillStyle = "#deb887";
            ctx.fill();
            ctx.strokeStyle = "#8b4513";
            ctx.stroke();
          } else {
            ctx.beginPath();
            ctx.rect(pos.cx - pos.width/2, pos.cy - pos.height/2, pos.width, pos.height);
            ctx.fillStyle = "#d2b48c";
            ctx.fill();
            ctx.strokeStyle = "#8b4513";
            ctx.stroke();
          }
        }
        // Draw seeds in the pit/store (up to 6 arranged in a small circle)
        let count = board[key].length;
        if (count > 0) {
          let seedsToDraw = Math.min(count, 6);
          let offsets = getSeedOffsets(seedsToDraw);
          let seedSize = 16;
          for (let i = 0; i < seedsToDraw; i++) {
            // Use the fixed seed object (do not randomize per draw)
            let seedImg = board[key][i];
            ctx.drawImage(seedImg, pos.cx + offsets[i].x - seedSize/2, pos.cy + offsets[i].y - seedSize/2, seedSize, seedSize);
          }
        }
        // Draw the counter (for pits: above the pit; for stores: above the top edge)
        ctx.fillStyle = "#000";
        ctx.font = "bold 16px sans-serif";
        ctx.textAlign = "center";
        if (pos.type === "pit") {
          ctx.fillText(count, pos.cx, pos.cy - pos.radius - 10);
        } else {
          ctx.fillText(count, pos.cx, pos.cy - pos.height/2 - 10);
        }
      }
      // Draw bottom bar text.
      ctx.fillStyle = "#fff";
      ctx.fillRect(0, HEIGHT - 30, WIDTH, 30);
      ctx.fillStyle = "#000";
      ctx.font = "16px sans-serif";
      ctx.textAlign = "left";
      ctx.fillText("Click a pit to move. Press [M] for menu.", 10, HEIGHT - 10);
      // Draw hand if visible.
      if (handVisible && handImg) {
        let handSize = 40;
        ctx.drawImage(handImg, handPos.x - handSize/2, handPos.y - handSize/2, handSize, handSize);
      }
    }

    function redraw() {
      drawBoard();
    }

    /*--------------------------
      Game Logic: Player and AI Moves
    ---------------------------*/
    function playerMakeMove(pitIndex) {
      if (isAnimating) return;
      if (!isOwnPit(pitIndex, currentPlayer)) return;
      if (board[pitIndex].length === 0) return;
      animateMove(pitIndex, function(extraTurn) {
        if (checkGameOver()) {
          gameState = "game_over";
          let winner = getWinner();
          let resultText = (winner === "tie") ? "It's a tie!" : (winner === playerSide ? "You win!" : "You lose!");
          document.getElementById("gameOverText").innerHTML = "Game Over<br>" + resultText;
          showGameOver();
          return;
        }
        if (!extraTurn) {
          currentPlayer = (currentPlayer === "south") ? "north" : "south";
        }
        redraw();
      });
    }

    // For AI moves, we use a simple minimax based on numeric counts.
    function boardToCounts() {
      let counts = [];
      for (let i = 0; i < board.length; i++) {
        counts[i] = board[i].length;
      }
      return counts;
    }
    function simulateMoveCounts(state, move, player) {
      let newState = state.slice();
      let stones = newState[move];
      newState[move] = 0;
      let index = move;
      while (stones > 0) {
        index = (index + 1) % 14;
        if (player === "south" && index === 13) continue;
        if (player === "north" && index === 6) continue;
        newState[index]++;
        stones--;
      }
      if (((player === "south" && move < 6) || (player === "north" && move >= 7 && move <= 12)) &&
          newState[index] === 1) {
        let opposite = 12 - index;
        if (newState[opposite] > 0) {
          let captured = newState[opposite] + newState[index];
          newState[opposite] = 0;
          newState[index] = 0;
          if (player === "south") newState[6] += captured;
          else newState[13] += captured;
        }
      }
      let extra = (player === "south" && index === 6) || (player === "north" && index === 13);
      return { state: newState, extra: extra };
    }
    function getLegalMovesForState(state, player) {
      let moves = [];
      if (player === "south") {
        for (let i = 0; i < 6; i++) { if (state[i] > 0) moves.push(i); }
      } else {
        for (let i = 7; i <= 12; i++) { if (state[i] > 0) moves.push(i); }
      }
      return moves;
    }
    function evaluateState(state, player) {
      return (player === "south") ? state[6] - state[13] : state[13] - state[6];
    }
    
    function getLegalMoves() {
  let moves = [];
  if (currentPlayer === "south") {
    for (let i = 0; i < 6; i++) {
      if (board[i].length > 0) moves.push(i);
    }
  } else if (currentPlayer === "north") {
    for (let i = 7; i <= 12; i++) {
      if (board[i].length > 0) moves.push(i);
    }
  }
  return moves;
}
    function minimaxDecision(state, player, depth) {
      function maxValue(state, player, depth) {
        let legal = getLegalMovesForState(state, player);
        if (depth === 0 || legal.length === 0) return { value: evaluateState(state, player), move: null };
        let best = { value: -Infinity, move: legal[0] };
        for (let move of legal) {
          let sim = simulateMoveCounts(state, move, player);
          let nextPlayer = sim.extra ? player : (player === "south" ? "north" : "south");
          let result = (nextPlayer === player) ? maxValue(sim.state, player, depth - 1) : minValue(sim.state, player, depth - 1);
          if (result.value > best.value) best = { value: result.value, move: move };
        }
        return best;
      }
      function minValue(state, player, depth) {
        let opponent = (player === "south") ? "north" : "south";
        let legal = getLegalMovesForState(state, opponent);
        if (depth === 0 || legal.length === 0) return { value: evaluateState(state, player), move: null };
        let best = { value: Infinity, move: null };
        for (let move of legal) {
          let sim = simulateMoveCounts(state, move, opponent);
          let nextPlayer = sim.extra ? opponent : player;
          let result = (nextPlayer === opponent) ? minValue(sim.state, player, depth - 1) : maxValue(sim.state, player, depth - 1);
          if (result.value < best.value) best = { value: result.value, move: move };
        }
        return best;
      }
      return maxValue(state, player, depth);
    }
    function aiMoveAction() {
      let legal = getLegalMoves();
      if (legal.length === 0) return;
      let chosen;
      if (difficulty === "easy") {
        chosen = legal[Math.floor(Math.random() * legal.length)];
      } else if (difficulty === "medium") {
        let state = boardToCounts();
        for (let move of legal) {
          let sim = simulateMoveCounts(state, move, currentPlayer);
          if (sim.extra) { chosen = move; break; }
        }
        if (chosen === undefined) chosen = legal[Math.floor(Math.random() * legal.length)];
      } else if (difficulty === "hard") {
        let state = boardToCounts();
        let decision = minimaxDecision(state, currentPlayer, 4);
        chosen = decision.move;
        if (chosen === null) chosen = legal[Math.floor(Math.random() * legal.length)];
      } else {
        chosen = legal[Math.floor(Math.random() * legal.length)];
      }
      animateMove(chosen, function(extraTurn) {
        if (checkGameOver()) {
          gameState = "game_over";
          let winner = getWinner();
          let resultText = (winner === "tie") ? "It's a tie!" : (winner === playerSide ? "You win!" : "You lose!");
          document.getElementById("gameOverText").innerHTML = "Game Over<br>" + resultText;
          showGameOver();
          return;
        }
        if (!extraTurn) {
          currentPlayer = (currentPlayer === "south") ? "north" : "south";
        }
        redraw();
      });
    }

    function checkGameOver() {
      let southEmpty = true;
      for (let i = 0; i < 6; i++) { if (board[i].length > 0) { southEmpty = false; break; } }
      let northEmpty = true;
      for (let i = 7; i <= 12; i++) { if (board[i].length > 0) { northEmpty = false; break; } }
      if (southEmpty || northEmpty) {
        if (!southEmpty) {
          for (let i = 0; i < 6; i++) { board[6] = board[6].concat(board[i]); board[i] = []; }
        }
        if (!northEmpty) {
          for (let i = 7; i <= 12; i++) { board[13] = board[13].concat(board[i]); board[i] = []; }
        }
        return true;
      }
      return false;
    }

    function getWinner() {
      if (board[6].length > board[13].length) return "south";
      if (board[13].length > board[6].length) return "north";
      return "tie";
    }

    /*--------------------------
      Input Handling
    ---------------------------*/
    canvas.addEventListener("mousedown", function(e) {
      if (gameState !== "playing" || isAnimating) return;
      if (currentPlayer !== playerSide) return;
      let rect = canvas.getBoundingClientRect();
      let mx = e.clientX - rect.left;
      let my = e.clientY - rect.top;
      let legal = getLegalMoves();
      for (let move of legal) {
        let pos = pitPositions[move];
        let dx = mx - pos.cx, dy = my - pos.cy;
        if (Math.sqrt(dx * dx + dy * dy) < pos.radius) {
          playerMakeMove(move);
          return;
        }
      }
    });
    document.addEventListener("keydown", function(e) {
      let key = e.key.toLowerCase();
      if (gameState === "side_choice") {
        if (key === "s") document.getElementById("southSideBtn").click();
        if (key === "n") document.getElementById("northSideBtn").click();
      } else if (gameState === "difficulty_choice") {
        if (key === "e") document.getElementById("easyBtn").click();
        if (key === "m") document.getElementById("mediumBtn").click();
        if (key === "h") document.getElementById("hardBtn").click();
      } else if (["playing", "instructions", "game_over"].includes(gameState)) {
        if (key === "m") showMenu();
      }
    });

    /*--------------------------
      Screen Management
    ---------------------------*/
    function hideAllScreens() {
      menuScreen.style.display = "none";
      instructionsScreen.style.display = "none";
      sideScreen.style.display = "none";
      difficultyScreen.style.display = "none";
      gameOverScreen.style.display = "none";
    }
    function showMenu() {
      hideAllScreens();
      gameState = "menu";
      menuScreen.style.display = "flex";
    }
    function showInstructions() {
      hideAllScreens();
      gameState = "instructions";
      instructionsScreen.style.display = "flex";
    }
    function showSideChoice() {
      hideAllScreens();
      gameState = "side_choice";
      sideScreen.style.display = "flex";
    }
    function showDifficultyChoice() {
      hideAllScreens();
      gameState = "difficulty_choice";
      difficultyScreen.style.display = "flex";
    }
    function showGameOver() {
      hideAllScreens();
      gameOverScreen.style.display = "flex";
    }

    /*--------------------------
      Main Loop
    ---------------------------*/
    function mainLoop() {
      if (gameState === "playing") {
        if (currentPlayer !== playerSide && !isAnimating && !aiThinking) {
          aiThinking = true;
          setTimeout(() => {
            aiMoveAction();
            aiThinking = false;
          }, 1000);
        }
      }
      requestAnimationFrame(mainLoop);
    }

    /*--------------------------
      Button Handlers
    ---------------------------*/
    document.getElementById("newGameBtn").onclick = function() { showSideChoice(); };
    document.getElementById("instructionsBtn").onclick = function() { showInstructions(); };
    document.getElementById("southSideBtn").onclick = function() {
      playerSide = "south";
      currentPlayer = "south";
      initBoard();
      redraw();
      showDifficultyChoice();
    };
    document.getElementById("northSideBtn").onclick = function() {
      playerSide = "north";
      currentPlayer = "north";
      initBoard();
      redraw();
      showDifficultyChoice();
    };
    document.getElementById("easyBtn").onclick = function() {
      difficulty = "easy";
      hideAllScreens();
      gameState = "playing";
    };
    document.getElementById("mediumBtn").onclick = function() {
      difficulty = "medium";
      hideAllScreens();
      gameState = "playing";
    };
    document.getElementById("hardBtn").onclick = function() {
      difficulty = "hard";
      hideAllScreens();
      gameState = "playing";
    };
    document.getElementById("gameOverNewGameBtn").onclick = function() { showSideChoice(); };

    /*--------------------------
      Start Everything
    ---------------------------*/
    computePitPositions();
    loadImages(function(){
      initBoard();
      redraw();
      mainLoop();
    });
  </script>
</body>
</html>
